I have implemented an FSK modulation scheme on GNU Radio. The initial block utilizes a WAV file source that produces a waveform corresponding to a file with a .wav extension. The output of this block ranges from -1 to 1. The next step involves multiplying this output by a constant of 128 using the 'Multiply Const' block, resulting in a range from -128 to 128. The subsequent 'float to char' block encodes each level within this range into 256 binary levels, where each level is represented by a byte. For instance, the level '2' is represented as binary '00000010'.

The output is then fed into the 'unpack K bits' block, which separates the byte into 8 individual bits. This output is subsequently directed to the 'stream to tagged stream' block with a packet length of '2728'. This block places an 'falign' tag at a length of 2728. The output is further sent to the 'Packet Header Generator' block with a header length of '48'. The initial 12 bits out of 48 represent the packet length '2728' in binary form as '101010101000', while the remaining 36 bits represent the packet ID.

The packet is structured as Header + Payload, with the 'falign' tag at the beginning of the header, and after the header is completed, the payload begins, extending to the packet length of 2728 bits. This process repeats cyclically. The output of this block is then routed to the 'Chunks to symbols' block, which generates a DC signal for '0' bits and a one-cycle cosine signal with a frequency of 100 times the sample rate for '1' bits.

This combined signal, consisting of DC and AC components, is multiplied by a carrier cosine signal with a frequency of 2MHz using the 'signal source' block for the carrier signal and the 'multiply' block. Since the cosine signal is complex, and the 'Chunks to symbols' block provides complex output from char input, the multiplication is conducted in the complex domain. The complex signal is then converted to a real signal using the 'Complex to real' block and directed to a 'virtual sink,' which serves as the end of the transmitter part. The modulated signal is subsequently decoded in the receiver part for demodulation.

 

the transmitted signal sent from virtual sink is recieved from 'virtual source' block which is demodulated by multiplying the signal with same carrier cosine signal with same frequency and amplitude such that there are two frequency components one is same signal as that sent from 'Chunks to symbols ' block with DC and AC signal for '0' and '1' symbol respectively and the other  component consists of double frequency . This signal is then sent through Low pass filter implemented using 'Low Pass Filter block' with cutoff freuqncy of 100k to let pass 32k and 0 frequnecy terms and stop 4MHz+32k freuqncy signal from passing high transition width of 550k is used to prevent stucking of output of low pass filter as lower transition width of low pass filter needs high computational resources. now this signal is slightly delay because of 'group filter delays' due to various filter used for demodulation, this delay is corrected using 'Delay' block setting variable value as 49 , the output of this block is then send to 'Decimating FIR Filter' this block is used for convolution and matching filter which integrates the signal consisting of both DC and AC part, integration of AC part gives integral value as '0' for 100 samples used in 'chunks to symbols' block and gives intergal value of '1' for DC Signal for 100 samples as the bits gets inverted for '1' it gives '0' annd for  '0' it gives '1' we correct it using multiplying output with -1 and then adding 1 to the output of this block, now as whole processing is done as float variables this output needs to be converted to Char , so for that I used 'Float to Char'.

now we have succesfully decoded the bits as '1's and '0's for further processing and now 'Tag gate' is placed to supress all the tags to stop interference of any tags in further procedure , now as  packet is represented with header+payload our next task is to remove header packet after succesfully identifying it and decode the packet length encoded in it and produce next packet length number of bits for payload, so for correctly identifying header packet we use 'Correlate Access Code - Tag ' block which correlates the sync word with incoming data packets and to correclty place tags that shows header starts from this point a delay of header packet length is placed parallely with correlation block such that 'corr_find' tag is placed at starting of the header+paylaod packet.

Now we use 'Header/Payload Demux' block for identifying the tag and and processs the header, after getting the header it checks whether the header length given as one of the parameters in this block matches the header length that it decoded from its input, for this operation we use 'Packet Header Parser' block which does exact inverse opeartion of that of 'Packet Header Generator' block . the 'Header/Payload Demux' block recieves trigger when it finds 'corr_find' tag in the header packet and as checking of header length and packet id is done by 'Packet Header Parser' if everything looks fine 'Header/Payload Demux' block outputs payload packets to 'out_payload' sink this can be packed into aa byte to represent 256 levels and then convert the char to float which gives float values as output then it can be divided by 128 to convert its range from '-128'-'128' to '-1' - '1' this operation gives back our waveform which was intially sent thus sound can be successfully heard using 'Audio sink' block and waveforms can be observed using 'QT GUI Time sink' block wherever required for debugging during popping up with errors . 
